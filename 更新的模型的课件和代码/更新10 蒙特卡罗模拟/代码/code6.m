%%  蒙特卡罗用于模拟导弹追击问题
% 注意，模拟导弹追击问题更像是一种仿真模拟的方法。这里本质上没有用到随机数，因此严格意义上不能称为蒙特卡罗。
clear; clc

%% （1）预备知识
% mod(m, n)表示求 m / n 的余数
mod(8, 3)
mod(1000, 50)

% 设置横纵坐标的范围并标上字符
x = 1:0.01:3;
y = x.^2;
plot(x, y) % 画出 x 和 y 的图形
axis([0, 3, 0, 10]) % 设置横坐标范围为 [0, 3] 纵坐标范围为 [0, 10]
pause(3) % 暂停 3 秒后再继续接下来的命令
text(2, 4, '清风') % 在坐标为 (2, 4) 的点上标上字符串：清风
close % 关闭图形窗口

%% (2) 代码求解
% 1．不画追击的示意图
clear; clc
v = 200; % 任意给定 B 船的速度（后期我们可以再改的）
dt = 0.0000001; % 定义时间间隔
x = [0, 20]; % 定义导弹和 B 船的横坐标分别为 x(1) 和 x(2)
y = [0, 0]; % 定义导弹和 B 船的纵坐标分别为 y(1) 和 y(2)
t = 0; % 初始化导弹击落 B 船的时间
d = 0; % 初始化导弹飞行的距离
m = sqrt(2) / 2; % 将 sqrt(2) / 2 定义为一个常量，使后面看起来很简洁
dd = sqrt((x(2) - x(1))^2+(y(2) - y(1))^2); % 导弹与 B 船的距离
while (dd >= 0.001) % 只要两者的距离足够大，就一直循环下去。（两者距离足够小时表示导弹击中，这里的临界值要结合 dt 来取，否则可能导致错过交界处的情况）
    t = t + dt; % 更新导弹击落 B 船的时间
    d = d + 3 * v * dt; % 更新导弹飞行的距离
    x(2) = 20 + t * v * m;
    y(2) = t * v * m; % 计算新的 B 船的位置 （注：m = sqrt(2) / 2）
    dd = sqrt((x(2) - x(1))^2+(y(2) - y(1))^2); % 更新导弹与 B 船的距离
    tan_alpha = (y(2) - y(1)) / (x(2) - x(1)); % 计算斜率，即 tan(α)
    cos_alpha = sqrt(1/(1 + tan_alpha^2)); % sec(α)^2 = 1 + tan(α)^2
    sin_alpha = sqrt(1-cos_alpha^2); % sin(α)^2 + cos(α)^2 = 1
    x(1) = x(1) + 3 * v * dt * cos_alpha;
    y(1) = y(1) + 3 * v * dt * sin_alpha; % 计算新的导弹的位置
    if d > 50 % 导弹的有效射程为 50 个单位
        disp('导弹没有击中 B 船');
        break; % 退出循环
    end
    if d <= 50 & dd < 0.001 % 导弹飞行的距离小于 50 个单位且导弹和 B 船的距离小于 0.001（表示击中）
        disp(['导弹飞行 ', num2str(d), ' 单位后击中 B 船'])
        disp(['导弹飞行的时间为 ', num2str(t*60), ' 分钟'])
    end
end

% 2．画追击的示意图
clear; clc
v = 200; % 任意给定 B 船的速度（后期我们可以再改的）
dt = 0.0000001; % 定义时间间隔
x = [0, 20]; % 定义导弹和 B 船的横坐标分别为 x(1) 和 x(2)
y = [0, 0]; % 定义导弹和 B 船的纵坐标分别为 y(1) 和 y(2)
t = 0; % 初始化导弹击落 B 船的时间
d = 0; % 初始化导弹飞行的距离
m = sqrt(2) / 2; % 将 sqrt(2) / 2 定义为一个常量，使后面看起来很简洁
dd = sqrt((x(2) - x(1))^2+(y(2) - y(1))^2); % 导弹与 B 船的距离
for i = 1:2
    plot(x(i), y(i), '.k', 'MarkerSize', 1); % 画出导弹和 B 船所在的坐标，点的大小为 1，颜色为黑色（k），用小点表示
    grid on; % 打开网格线
    hold on; % 不关闭图形，继续画图
end
axis([0, 30, 0, 10]) % 固定 x 轴的范围为 0-30，固定 y 轴的范围为 0-10
k = 0; % 引入一个变量，为了控制画图的速度（因为 MATLAB 中画图的速度超级慢）
while (dd >= 0.001) % 只要两者的距离足够大，就一直循环下去。（两者距离足够小时表示导弹击中，这里的临界值要结合 dt 来取，否则可能导致错过交界处的情况）
    t = t + dt; % 更新导弹击落 B 船的时间
    d = d + 3 * v * dt; % 更新导弹飞行的距离
    x(2) = 20 + t * v * m;
    y(2) = t * v * m; % 计算新的 B 船的位置 （注：m=sqrt(2)/2）
    dd = sqrt((x(2) - x(1))^2+(y(2) - y(1))^2); % 更新导弹与 B 船的距离
    tan_alpha = (y(2) - y(1)) / (x(2) - x(1)); % 计算斜率，即 tan(α)
    cos_alpha = sqrt(1/(1 + tan_alpha^2)); % 利用公式 sec(α)^2 = (1 + tan(α)^2) 计算出 cos(α)
    sin_alpha = sqrt(1-cos_alpha^2); % 利用公式 sin(α)^2 +cos(α)^2 = 1 计算出 sin(α)
    x(1) = x(1) + 3 * v * dt * cos_alpha;
    y(1) = y(1) + 3 * v * dt * sin_alpha; % 计算新的导弹的位置
    k = k + 1;
    if mod(k, 500) == 0 % 每刷新 500 次时间就画出下一个导弹和 B 船所在的坐标，mod(m, n)表示求 m / n 的余数
        for i = 1:2
            plot(x(i), y(i), '.k', 'MarkerSize', 1);
            hold on; % 不关闭图形，继续画图
        end
        pause(0.001); % 暂停 0.001 s 后再继续下面的操作
    end
    if d > 50 % 导弹的有效射程为 50 个单位
        disp('导弹没有击中 B 船');
        break; % 退出循环
    end
    if d <= 50 & dd < 0.001 % 导弹飞行的距离小于 50 个单位且导弹和 B 船的距离小于 0.001（表示击中）
        disp(['导弹飞行 ', num2str(d), ' 个单位后击中 B 船'])
        disp(['导弹飞行的时间为 ', num2str(t*60), ' 分钟'])
    end
end


% % 注意：代码文件仅供参考，一定不要直接用于自己的数模论文中
% % 国赛对于论文的查重要求非常严格，代码雷同也算作抄袭