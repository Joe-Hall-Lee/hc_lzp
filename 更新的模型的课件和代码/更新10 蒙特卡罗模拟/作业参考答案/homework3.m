%%  蒙特卡罗求解非线性规划问题
% min f(x) =2*(x1^2)+x2^2-x1*x2-8*x1-3*x2
% s.t.
% (1) 3 * x1 + x2 > 9
% (2) x1 + 2 * x2 < 16
% (3) x1 > 0 & x2 > 0

%% （1）初次寻找最小值的代码
clc, clear;
format long g % 可以将 Matlab 的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）
tic % 计算 tic 和 toc 中间部分的代码的运行时间
n = 10000000; %生成的随机数组数
x1 = unifrnd(0, 16, n, 1); % 生成在[0,16]之间均匀分布的随机数组成的 n 行 1 列的向量构成 x1
x2 = unifrnd(0, 8, n, 1); % 生成在[0,8]之间均匀分布的随机数组成的 n 行 1 列的向量构成 x2
fmin = +inf; % 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）
for i = 1:n
    x = [x1(i), x2(i)]; %构造x向量, 这里千万别写成了：x =[x1, x2]
    if (3 * x(1) + x(2) > 9) & (x(1) + 2 * x(2) < 16) % 判断是否满足条件
        result = 2 * (x(1)^2) + x(2)^2 - x(1) * x(2) - 8 * x(1) - 3 * x(2); % 如果满足条件就计算函数值
        if result < fmin % 如果这个函数值小于我们之前计算出来的最小值
            fmin = result; % 那么就更新这个函数值为新的最小值
            X = x; % 并且将此时的 x1、x2 保存到相应的变量中
        end
    end
end
disp(strcat('蒙特卡罗模拟得到的最小值为', num2str(fmin)))
disp('最小值处 x1、x2 的取值为：')
disp(X)
toc % 计算 tic 和 toc 中间部分的代码的运行时间

%% （2）缩小范围重新模拟得到更加精确的取值
clc, clear;
tic % 计算 tic 和 toc 中间部分的代码的运行时间
n = 10000000; % 生成的随机数组数
x1 = unifrnd(2, 3, n, 1); % 生成在 [2, 3] 之间均匀分布的随机数组成的 n 行 1 列的向量构成 x1
x2 = unifrnd(2, 3, n, 1); % 生成在 [2, 3] 之间均匀分布的随机数组成的 n 行 1 列的向量构成 x2
fmin = +inf; % 初始化函数 f 的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）
for i = 1:n
    x = [x1(i), x2(i)]; % 构造 x 向量, 这里千万别写成了：x = [x1, x2]
    if (3 * x(1) + x(2) > 9) & (x(1) + 2 * x(2) < 16) % 判断是否满足条件
        result = 2 * (x(1)^2) + x(2)^2 - x(1) * x(2) - 8 * x(1) - 3 * x(2); % 如果满足条件就计算函数值
        if result < fmin % 如果这个函数值小于我们之前计算出来的最小值
            fmin = result; % 那么就更新这个函数值为新的最小值
            X = x; % 并且将此时的 x1、x2 保存到相应的变量中
        end
    end
end
disp(strcat('蒙特卡罗模拟得到的最小值为', num2str(fmin)))
disp('最小值处 x1、x2 的取值为：')
disp(X)
toc % 计算 tic 和 toc 中间部分的代码的运行时间


% % 注意：代码文件仅供参考，一定不要直接用于自己的数模论文中
% % 国赛对于论文的查重要求非常严格，代码雷同也算作抄袭
